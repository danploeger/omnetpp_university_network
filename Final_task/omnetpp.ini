[General]
network = University
#Simulation eines typischen 8 Std Tages .
sim-time-limit= 7200s #8 std         # 7200s = 2Std      , 43200 = 12 Std 
repeat = 1
##Statistics Thruputmeter-Settings
**.thruputMeter.**.vector-recording = true	
# disable all others
#**.vector-recording = false

**.udpApp[*].**.vector-recording = true
**.tcpApp[*].**.vector-recording = true
# throughputmeter: Best is to undo the code change recommended in exercise 6
**.maxInterval = 1s	# interval for the throughputmeters
**.batchSize = 10000 # batch size for the throughputmeters
**.interfaceTable.displayAddresses = true
*.configurator.assignAddresses = true
##*.configurator.addStaticRoutes = false
##Routing - mainR kann WlanHostIPs nicht routen. In xml steht welches der nächste Hop ist.
**.networkConfiguratorModule = default #absolut path to configurator
**.configurator.config = xmldoc("config.xml")


# NIC settings
**.mac.address = "auto"
**.mac.maxQueueSize = 14
**.mac.rtsThresholdBytes = 3000B
**.wlan[*].mac.retryLimit = 7
**.wlan[*].mac.cwMinData = 7
**.wlan[*].mac.cwMinMulticast = 31
**.opMode = "g"
**.mgmt.frameCapacity = 50

#Mobility
**.constraintAreaMinX = 0m
**.constraintAreaMinY = 0m
**.constraintAreaMinZ = 0m
#AreaConstraints fuer mobile Knoten - brauche ich die ? habe nur stationäre Knoten
**.constraintAreaMaxX = 600m # Raum 400m^2  -> (20*20)m
**.constraintAreaMaxY = 400m
**.constraintAreaMaxZ = 0m

**.accessPoint.mobilityType ="StationaryMobility"
**.whostFTP.mobilityType = "StationaryMobility"
**.whttpStudents[*].mobilityType = "StationaryMobility"
**.whostVideoConf.mobilityType = "StationaryMobility"
##From Task "Students are uniformly distributed in a 400m2 area around the access point"
**.whttpStudents[*].mobility.initialX =normal(12m, 0.8m) #ausgedacht nicht begruendet: 
**.whttpStudents[*].mobility.initialY =normal(13m, 0.5m)
**.[names of mobile stations].mobility.initialZ = 0m

**.channelNumber = 0
**.mobility.initFromDisplayString = false
**.accessPoint.mobility.initialX = 25m #AccessPoint sitzt an den Kooridinaten, user in 400m2 area drumherum
**.accessPoint.mobility.initialY = 25m
**.accessPoint.mobility.initialZ = 0m

#**.tcpType = "TCP"
# TCPNewReno (Fast Retransmit and Fast Recovery)
**.tcp.tcpAlgorithmClass = "TCPNewReno"
**.tcp.windowScalingSupport = true
**.tcpApp[*].dataTransferMode = "object" # transmit cPacket objects (and subclasses) over a TCP connection
**.tcpApp[*].startTime =1s
#Die Maximum Transmission Unit (MTU; deutsch maximale Übertragungseinheit) beschreibt die maximale
# Paketgröße eines Protokolls der Vermittlungsschicht (Schicht 3) des OSI-Modells, gemessen in Oktetten, welche ohne Fragmentierung in den Rahmen (engl. "Frames")
# eines Netzes der Sicherungsschicht (Schicht 2) übertragen werden kann.
##MTU in Ethernet is 1500Byte -> Nutzdaten von TCP muss <1500Byte-TCPHeader - IPHeader.
**.tcp.mss =1460
#Advertised Window:---------------------------------------
#AWS (Advertised Window Size, Sendergröße) wird variabel angepasst und mit dem Empfänger abgeglichen um eine momentan ideale Datenrate zu finden.
#Der Empfänger "steuert" den Sender (drosselt/beschleunigt) durch Angabe der Größe des Senderfensters ("advertising the window size"), 
#AWS = Anzahl der Bytes die der Empfänger bereit ist zu empfangen 
##Client gibt in jedem tcp segment folgendes an den Sender zurück:
## AckNumber (AckFlag has to be set) : welches TCP Segement erwarte ich als nächstes
##Receive Window : Anzahl der Bytes die ich bereit bin zu speichern.
#flow control! 
#receive queue of WirelessHost * mss = advWindow. 
#Annahme: Receive Queue der empfänger wird sofort geleert. Daher size(advWin)=size(Receive queue)
**.tcp.advertisedWindow = 1000*1460 # 14 ist magische default angabe

##Server
**.Server.numTcpApps = 2
**.Server.tcpApp[0].typename = "TCPGenericSrvApp"
**.Server.tcpApp[0].localPort= 80   #Server listens on Port 80
**.Server.tcpApp[0].replyDelay= 0s   #Replies immediately

**.Server.tcpApp[1].typename ="TCPGenericSrvApp"
**.Server.tcpApp[1].localPort = 20
**.Server.tcpApp[1].replyDelay = 0s


##Client
##HTTPClients - Surfing the Internet
**.whttpStudents[*].numTcpApps = 1
**.tcpApp[*].typename ="TCPBasicClientApp"
**.wirelessNet.whttpStudents[*].tcpApp[0].connectAddress ="Server" #Clients connect to symbolic Address
**.wirelessNet.whttpStudents[*].tcpApp[0].connectPort =80 #Port to connect to
**.wirelessNet.whttpStudents[*].tcpApp[0].localPort = -1  #wähle einen freien Port (nochmal nachgucken wo das steht)  


**.wirelessNet.whttpStudents[*].tcpApp[0].numRequestsPerSession = 1 #(HTTP 1.0 click auf einer webseite)
**.wirelessNet.whttpStudents[*].tcpApp[0].requestLength = truncnormal(350B,20B)      #Length of the request sent.		   																			
**.wirelessNet.whttpStudents[*].tcpApp[0].thinkTime = 1s  #Time gap between requests (clicking, loading content)
**.wirelessNet.whttpStudents[*].tcpApp[0].reconnectInterval = 30s #Falls connection broken, abwarten bis erneut versucht wird eine Verbindung aufzubauen
**.wirelessNet.whttpStudents[*].tcpApp[].stopTime = -1s         #Senden bis fertig.
##ParameterSheet - Group Specific Parameter
**.wirelessNet.whttpStudents[*].tcpApp[0].idleInterval =exponential(15s)    #Time gap between sessions
**.wirelessNet.whttpStudents[*].tcpApp[0].replyLength = exponential(2.345B)      #TODO(daniel): Replay length from tracefile10

##FTPClient - uploading File to Server
**.whostFTP.numTcpApps = 1
**.wirelessNet.whostFTP.tcpApp[0].connectAddress ="Server"
**.wirelessNet.whostFTP.tcpApp[0].connectPort = 20
**.wirelessNet.whostFTP.tcpApp[0].localPort = -1
##File to transmit is 12GiB bei simtime=1000s
##12GiB/1460B = numRequestsPer Session
## FTP upload. Medelliert als Client der wiederholt Sessions zum Server aufbaut um ein Request a 1460B zu senden.
## "Upload is considered as one large file transfer lasting the whole simulation"
**.wirelessNet.whostFTP.tcpApp[0].numRequestsPerSession = default  # 1 
**.wirelessNet.whostFTP.tcpApp[0].requestLength = 1460B    # mss, no fragmentation 
**.wirelessNet.whostFTP.tcpApp[0].replyLength = 1B         

##CCTVCamera  - StandardHostModul

**.CCTV.numUdpApps = 1
**.CCTV.udpApp[*].typename = "UDPVideoStreamSvr"
**.CCTV.udpApp[*].localPort = 40
**.CCTV.udpApp[*].sendInterval = 1s
**.CCTV.udpApp[*].packetLen = 1460B


##CCTVMonitoring Host - StandardHost
**.ccTVMonitoringHost.numUdpApps = 1
**.ccTVMonitoringHost.udpApp[*].typename = "UDPVideoStreamCli"

##Aus dem Aufgabenblatt


##WirelessHost wHostVideoConf hat Apps:
##Video/UDPApp : 1  (connectAddress "profLaptop")

##StandartHost profLaptop hat Apps:
##Video/UDPApp: 1  (verbunden mit whostVideoConf - > profLaptop = Server der Video bereitstellt?)

## StandardHost ccTVMonitoringHost hat Apps:
##UDPApp:1      -


