[General]
network = University
#Simulation einer 2 Std Vorlesung
sim-time-limit= 7200s #2 std         # 7200s = 2Std      , 43200 = 12 Std 
repeat = 1
##Statistics Thruputmeter-Settings
**.thruputMeter.**.vector-recording = true	
# disable all others
#**.vector-recording = false

**.udpApp[*].**.vector-recording = true
**.udpApp[*].rcvdPkLifetime.result-recording-modes = all
**.tcpApp[*].**.vector-recording = true
# throughputmeter: Best is to undo the code change recommended in exercise 6
**.maxInterval = 1s	# interval for the throughputmeters
**.batchSize = 10000 # batch size for the throughputmeters
**.interfaceTable.displayAddresses = true
*.configurator.assignAddresses = true
##*.configurator.addStaticRoutes = false
##Routing - mainR kann WlanHostIPs nicht routen. In xml steht welches der nächste Hop ist.
**.networkConfiguratorModule = default #absolut path to configurator
**.configurator.config = xmldoc("config.xml")


# NIC settings
**.mac.address = "auto"
**.mac.maxQueueSize = 14
**.mac.rtsThresholdBytes = 3000B
**.wlan[*].mac.retryLimit = 7
**.wlan[*].mac.cwMinData = 7
**.wlan[*].mac.cwMinMulticast = 31
**.opMode = "g"
**.mgmt.frameCapacity = 50

#Mobility
**.constraintAreaMinX = 0m
**.constraintAreaMinY = 0m
**.constraintAreaMinZ = 0m
#AreaConstraints fuer mobile Knoten - brauche ich die ? habe nur stationäre Knoten
**.constraintAreaMaxX = 600m # Raum 400m^2  -> (20*20)m
**.constraintAreaMaxY = 400m
**.constraintAreaMaxZ = 0m

**.accessPoint.mobilityType ="StationaryMobility"
**.whostFTP.mobilityType = "StationaryMobility"
**.whttpStudents[*].mobilityType = "StationaryMobility"
**.whostVideoConf.mobilityType = "StationaryMobility"
##From Task "Students are uniformly distributed in a 400m2 area around the access point"
**.w*.mobility.initialX =uniform(25m, 0.4m) #ausgedacht nicht begruendet: 
**.w*.mobility.initialY =uniform(25m, 0.4m)
**.w*.mobility.initialZ = 0m

**.channelNumber = 0
**.mobility.initFromDisplayString = false
**.accessPoint.mobility.initialX = 25m #AccessPoint sitzt an den Kooridinaten, user in 400m2 area drumherum
**.accessPoint.mobility.initialY = 25m
**.accessPoint.mobility.initialZ = 0m

#**.tcpType = "TCP"
# TCPNewReno (Fast Retransmit and Fast Recovery)
**.tcp.tcpAlgorithmClass = "TCPNewReno"
**.tcp.windowScalingSupport = true
**.tcpApp[*].dataTransferMode = "object" # transmit cPacket objects (and subclasses) over a TCP connection
**.tcpApp[*].startTime = exponential(15s)
#Die Maximum Transmission Unit (MTU; deutsch maximale Übertragungseinheit) beschreibt die maximale
# Paketgröße eines Protokolls der Vermittlungsschicht (Schicht 3) des OSI-Modells, gemessen in Oktetten, welche ohne Fragmentierung in den Rahmen (engl. "Frames")
# eines Netzes der Sicherungsschicht (Schicht 2) übertragen werden kann.
##MTU in Ethernet is 1500Byte -> Nutzdaten von TCP muss <1500Byte-TCPHeader - IPHeader.
**.tcp.mss =1460
#Advertised Window:---------------------------------------
#AWS (Advertised Window Size, Sendergröße) wird variabel angepasst und mit dem Empfänger abgeglichen um eine momentan ideale Datenrate zu finden.
#Der Empfänger "steuert" den Sender (drosselt/beschleunigt) durch Angabe der Größe des Senderfensters ("advertising the window size"), 
#AWS = Anzahl der Bytes die der Empfänger bereit ist zu empfangen 
##Client gibt in jedem tcp segment folgendes an den Sender zurück:
## AckNumber (AckFlag has to be set) : welches TCP Segement erwarte ich als nächstes
##Receive Window : Anzahl der Bytes die ich bereit bin zu speichern.
#flow control! 
#receive queue of WirelessHost * mss = advWindow. 
#Annahme: Receive Queue der empfänger wird sofort geleert. Daher size(advWin)=size(Receive queue)
**.tcp.advertisedWindow = 1000*1460

##Server
#**.Server.numTcpApps = 2
**.Server.tcpApp[0].typename = "TCPGenericSrvApp"
**.Server.tcpApp[0].localPort= 80   #Server listens on Port 80
**.Server.tcpApp[0].replyDelay= 0s   #Replies immediately

**.Server.tcpApp[1].typename ="TCPGenericSrvApp"
**.Server.tcpApp[1].localPort = 20
**.Server.tcpApp[1].replyDelay = 0s


##Client
##HTTPClients - Surfing the Internet
**.whttpStudents[*].numTcpApps = 1
**.tcpApp[*].typename ="TCPBasicClientApp"
**.wirelessNet.whttpStudents[*].tcpApp[0].connectAddress ="Server" #Clients connect to symbolic Address
**.wirelessNet.whttpStudents[*].tcpApp[0].connectPort =80 #Port to connect to
**.wirelessNet.whttpStudents[*].tcpApp[0].localPort = -1  #wähle einen freien Port (nochmal nachgucken wo das steht)  


**.wirelessNet.whttpStudents[*].tcpApp[0].numRequestsPerSession = 1 #(HTTP 1.0 click auf einer webseite)
**.wirelessNet.whttpStudents[*].tcpApp[0].requestLength = default      #Length of the request sent.		   																			
**.wirelessNet.whttpStudents[*].tcpApp[0].thinkTime = 0s  #Time gap between requests (clicking, loading content)
**.wirelessNet.whttpStudents[*].tcpApp[0].reconnectInterval = 30s #Falls connection broken, abwarten bis erneut versucht wird eine Verbindung aufzubauen
**.wirelessNet.whttpStudents[*].tcpApp[].stopTime = -1s         #Senden bis fertig.
##ParameterSheet - Group Specific Parameter
**.wirelessNet.whttpStudents[*].tcpApp[0].idleInterval = exponential(15s)    #Time gap between sessions
**.wirelessNet.whttpStudents[*].tcpApp[0].replyLength = exponential(0.789MiB)      #Reply length from tracefile10

##FTPClient - uploading File to Server
**.whostFTP.numTcpApps = 1
**.wirelessNet.whostFTP.tcpApp[0].thinkTime = 0s
**.wirelessNet.whostFTP.tcpApp[0].idleInterval=0s
**.wirelessNet.whostFTP.tcpApp[0].connectAddress ="Server"
**.wirelessNet.whostFTP.tcpApp[0].connectPort = 20
**.wirelessNet.whostFTP.tcpApp[0].localPort = -1
##File to transmit is 12GiB bei simtime=1000s
##12GiB/1460B = numRequestsPer Session
## FTP upload. Medelliert als Client der wiederholt Sessions zum Server aufbaut um ein Request a 1460B zu senden.
## "Upload is considered as one large file transfer lasting the whole simulation"
**.wirelessNet.whostFTP.tcpApp[0].numRequestsPerSession = default  # 1 
**.wirelessNet.whostFTP.tcpApp[0].requestLength = 1460GiB    # mss, no fragmentation 
**.wirelessNet.whostFTP.tcpApp[0].replyLength = 0B         

##CCTVCamera  - StandardHostModul
**.CCTV.numUdpApps = 1
**.CCTV.udpApp[*].typename = "UDPVideoStreamSvr"
**.CCTV.udpApp[*].localPort = 40
**.CCTV.udpApp[*].sendInterval = 40ms
**.CCTV.udpApp[*].packetLen = 10KiB
##Wenn die Simulation 2 Std dauert, schickt die kamera ca 180000 packete à 10KiB
**.CCTV.udpApp[*].videoSize = 180000*10KiB    #7200000ms/40ms = 180000 packete 

##CCTVMonitoring Host - StandardHost
**.ccTVMonitoringHost.numUdpApps = 1
**.ccTVMonitoringHost.udpApp[*].typename = "UDPVideoStreamCli"
**.ccTVMonitoringHost.udpApp[*].serverAddress = "CCTV"
**.ccTVMonitoringHost.udpApp[*].serverPort = 40
**.ccTVMonitoringHost.udpApp[*].localPort = -1
##Aus dem Aufgabenblatt


##WirelessHost wHostVideoConf hat Apps:
##Video/UDPApp : 1  (connectAddress "profLaptop")

##StandartHost profLaptop hat Apps:
##Video/UDPApp: 1  (verbunden mit whostVideoConf - > profLaptop = Server der Video bereitstellt?)
#
#  profLaptop
**.profLaptop.numUdpApps = 1
**.profLaptop.udpApp[0].typename = "UDPBasicApp"
**.profLaptop.udpApp[0].localPort = 1001
**.profLaptop.udpApp[0].destAddresses = "10.0.0.2"
**.profLaptop.udpApp[0].destPort = 1000
**.profLaptop.udpApp[0].sendInterval = 40ms
**.profLaptop.udpApp[0].messageLength = 1400B 	# 1388B video + 12B RTP header
**.profLaptop.udpApp[0].startTime = uniform(0s, 40ms)

#  whostVideoConf

**.whostVideoConf.numUdpApps = 1
**.whostVideoConf.udpApp[0].typename = "UDPBasicApp"
**.whostVideoConf.udpApp[0].localPort = 1000
**.whostVideoConf.udpApp[0].destAddresses = "10.0.0.14"
**.whostVideoConf.udpApp[0].destPort = 1001
**.whostVideoConf.udpApp[0].sendInterval = 40ms
**.whostVideoConf.udpApp[0].messageLength = 1400B 	# 1388B video + 12B RTP header
**.whostVideoConf.udpApp[0].startTime = uniform(0s, 40ms)
#
#**.udpApp[0].typename="UDPBasicApp"
#**.Server.udpApp[0].localPort = 1005
#**.Server.udpApp[0].destAddresses = "10.0.0.14"
#**.Server.udpApp[0].destPort = 1200


